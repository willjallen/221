///////////////////////////////////////////////////////////////
//  File:   InnerSuqareList.cpp
//  Course: CSCE-221 Data Structures & Algorithms
//  Author: 
//  Date:   9/6/2019
//  Usage:  You have to complete the implementation
///////////////////////////////////////////////////////////////

#include "InnerSquareList.h"

InnerSquareList::InnerSquareList()
{
	m_header = nullptr;
	m_tail = nullptr;
	m_length = 0;
}

InnerSquareList::InnerSquareList(Node* const header, Node* const tail, const size_t length)
{

	m_header = header;
	m_tail = tail;
	m_length = length;
}


InnerSquareList::~InnerSquareList()
{
}

void InnerSquareList::clean()
{
	//delete all nodes generated by "new"
	while (m_header)
	{
		Node* pt = m_header;
		m_header = m_header->next;
		delete pt;
	}
	m_tail = m_header;
	m_length = 0;
}

Node* InnerSquareList::getHeader() const
{
	return m_header;
}

Node* InnerSquareList::getTail() const
{
	return m_tail;
}

void InnerSquareList::add(const int pos, const int data)
{
	if (0 == pos)
	{
		Node* node = new Node;
		node->value = data;
		node->next = m_header;
		m_header = node;
		m_length++;
		//update tail pointer for the first element to an empty inner list
		if (1 == m_length)
			m_tail = m_header;
		return;
	}

	if (pos > 0 && pos <= (int)m_length)
	{
		Node* pt = m_header;
		for (int i = 1; i < pos; i++)
		{
			pt = pt->next;
		}
		Node* node = new Node;
		node->value = data;
		node->next = pt->next;
		pt->next = node;
		//update tail pointer when inserted new last node
		if (pos == (int)m_length)
		{
			m_tail = node;
		}
		m_length++;
	}
}

void InnerSquareList::addFirst(const int data)
{
	//call the general insertion function
	add(0, data);
}

void InnerSquareList::addLast(const int data)
{
	if (!m_length)
	{
		//if the list is emepty, the last element is also the first element
		add(0, data);
		return;
	}

	Node* node = new Node;
	node->value = data;
	node->next = nullptr;
	m_tail->next = node;
	m_tail = node;
	m_length++;
}

int InnerSquareList::remove(const int pos)
{
	//delete the first node
	if (0 == pos && m_length > 0)
	{
		Node* pt = m_header;
		m_header = m_header->next;
		int value = pt->value;
		delete pt;
		m_length--;
		return value;
	}

	//delete other nodes
	if (pos > 0 && pos < (int)m_length)
	{
		Node* pt = m_header;
		for (int i = 1; i < pos; i++)
		{
			pt = pt->next;
		}
		Node* node = pt->next;
		pt->next = node->next;
		int val = node->value;
		delete node;
		//update tail pointer if the last node is deleted
		if (((int)m_length - 1) == pos)
		{
			m_tail = pt;
		}
		m_length--;
		return val;
	}

	return INTNULL;
}

int InnerSquareList::get(const int pos) const
{
	if (pos >= 0 && pos < (int)m_length)
	{
		Node* pt = m_header;
		for (int i = 0; i < pos; i++)
		{
			pt = pt->next;
		}
		return pt->value;
	}
	else
	{
		return INTNULL;
	}
}

void InnerSquareList::set(const int pos, const int data)
{
	if (pos >= 0 && pos < (int)m_length)
	{
		Node* pt = m_header;
		for (int i = 0; i < pos; i++)
		{
			pt = pt->next;
		}
		pt->value = data;
	}
}

int InnerSquareList::indexOf(const int data) const
{
	Node* pt = m_header;
	int id = 0;
	while (pt)
	{
		if (data == pt->value)
		{
			return id;
		}
		pt = pt->next;
		id++;
	}
	//not found
	return -1;
}

size_t InnerSquareList::size() const
{
	return m_length;
}

void InnerSquareList::merge(InnerSquareList &isl)
{
	//do not merge with self
	if(isl.getHeader()!= m_header && isl.getHeader() != m_tail && isl.getTail() != m_header && isl.getTail() != m_tail)
	{
		m_tail->next = isl.getHeader();
		m_tail = isl.getTail();
		m_length += isl.size();
	}
}

InnerSquareList InnerSquareList::split()
{
	//the first half is the small or one element smaller than the second
	int numFirst = m_length / 2;
	int numSecond = m_length - numFirst;

	//find the spliting point
	Node* pt = m_header;
	for (int i = 0; i < numFirst - 1; i++)
	{
		pt = pt->next;
	}

	//ruct the second half
	InnerSquareList secondHalf(pt->next, m_tail, numSecond);
	pt->next = nullptr;
	//cut the first half
	m_tail = pt;
	m_length = numFirst;
	return secondHalf;
}

void InnerSquareList::dump() const
{
	//check the format from the sample output
	std::cout << "=========================================================" << std::endl;
	std::cout << "InnerList dump :" << std::endl;
	std::cout << "size = " << m_length << std::endl;
	Node* pt = m_header;
	while (pt)
	{
		std::cout << "[" << pt->value << "] ";
		pt = pt->next;
	}
	std::cout << std::endl;
	std::cout << "tail.data = " << m_tail->value << std::endl;
}